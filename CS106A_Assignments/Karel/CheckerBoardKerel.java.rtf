{\rtf1\ansi\ansicpg1252\cocoartf1187\cocoasubrtf370
{\fonttbl\f0\fmodern\fcharset0 CourierNewPSMT;\f1\fmodern\fcharset0 CourierNewPS-BoldMT;\f2\fswiss\fcharset0 Helvetica;
}
{\colortbl;\red255\green255\blue255;\red15\green114\blue3;\red255\green255\blue255;\red0\green0\blue0;
\red10\green82\blue135;\red217\green217\blue217;\red251\green0\blue7;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720

\itap1\trowd \taflags0 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalt\clvertalbase \clshdrawnil \clwWidth18200\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadl0 \clpadr0 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\sl260

\f0\fs24 \cf2 \cb3 /*\cf0 \
\'a0\cf2 * File: CheckerboardKarel.java\cf0 \
\'a0\cf2 * ----------------------------\cf0 \
\'a0\cf2 * CheckerboardKarel creates a checkerboard pattern for a world of\cf0 \
\'a0\cf2 * any size. Karel will move from left to right as it lays down the \cf0 \
\'a0\cf2 * checkerboard pattern before returing to the first column and moving\cf0 \
\'a0\cf2 * up to the next row.\'a0 \cf0 \
\'a0\cf2 */\cf0 \
\'a0\
import stanford.karel.*;\
\'a0\
\pard\intbl\itap1\pardeftab720\sl260

\f1\b \cf5 \cb6 public
\f0\b0 \cf0  
\f1\b \cf5 class
\f0\b0 \cf0  CheckerboardKarel extends SuperKarel \{\
\pard\intbl\itap1\pardeftab720\sl260\sa240

\f2 \cf0 \cb3 Overall, great! There's just a few problems with edge cases.\
\pard\intbl\itap1\pardeftab720\sl220

\i\fs20 \cf0 Lekan Wang (lekanw)\
\pard\intbl\itap1\pardeftab720\sl260

\f0\i0\fs24 \cf0 \
\'a0\
\'a0\'a0\'a0\'a0
\f1\b \cf5 public
\f0\b0 \cf0  
\f1\b \cf5 void
\f0\b0 \cf0  run()\{\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0
\f1\b \cf5 while
\f0\b0 \cf0  (frontIsClear())\{\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0checkerRow();\
\pard\intbl\itap1\pardeftab720\sl260
\cf0 \cb6 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0checkForBeeperLastColumn();\
\pard\intbl\itap1\pardeftab720\sl260\sa240

\f2 \cf0 \cb3 Why is this necessary? checkerRow seems to always do the right thing.\
\pard\intbl\itap1\pardeftab720\sl220

\i\fs20 \cf0 Lekan Wang (lekanw)\
\pard\intbl\itap1\pardeftab720\sl260

\f0\i0\fs24 \cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0returnToFirstAvenue();\
\pard\intbl\itap1\pardeftab720\sl260
\cf0 \cb6 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0checkForBeeperFirstColumn();\
\pard\intbl\itap1\pardeftab720\sl260\sa240

\f2 \cf7 \cb3 Hmm. This will move forward one step if we are on an "even" row (2,4,6,8) are checkered. But what if the world is only 2 wide? Then, the while loop will check that front is NOT clear, and the program will end. :(\
\pard\intbl\itap1\pardeftab720\sl220

\i\fs20 \cf7 Lekan Wang (lekanw)\
\pard\intbl\itap1\pardeftab720\sl260

\f0\i0\fs24 \cf7 \
\pard\intbl\itap1\pardeftab720\sl260
\cf0 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\}\
\pard\intbl\itap1\pardeftab720\sl260
\cf0 \cb6 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0
\f1\b \cf5 if
\f0\b0 \cf0  (frontIsBlocked() && rightIsBlocked() && leftIsClear())\{\
\pard\intbl\itap1\pardeftab720\sl260\sa240

\f2 \cf0 \cb3 Would be nice to comment this section. It took me a bit to figure out what this was for.\
\pard\intbl\itap1\pardeftab720\sl220

\i\fs20 \cf0 Lekan Wang (lekanw)\
\pard\intbl\itap1\pardeftab720\sl260

\f0\i0\fs24 \cf0 \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0checkerColumn();\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0checkForBeeperLastColumn();\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\}\
\'a0\'a0\'a0\'a0\}\
\'a0\'a0\'a0\'a0\'a0\
\pard\intbl\itap1\pardeftab720\sl260
\cf2 \cb6 /* Creates a checkerboard pattern for a row of any length.\cf0 \
\'a0\cf2 * Precondition: Karel is on First Avenue facing east.\cf0 \
\'a0\cf2 * Post condition: Karel ends on the last column and the row has been\cf0 \
\'a0\cf2 * checkered.\cf0 \
\'a0\cf2 */\cf0 \
\pard\intbl\itap1\pardeftab720\sl260\sa240

\f2 \cf0 \cb3 In general, great, great decomposition and commenting.\
\pard\intbl\itap1\pardeftab720\sl220

\i\fs20 \cf0 Lekan Wang (lekanw)\
\pard\intbl\itap1\pardeftab720\sl260

\f0\i0\fs24 \cf0 \
\'a0\'a0\'a0\'a0
\f1\b \cf5 private
\f0\b0 \cf0  
\f1\b \cf5 void
\f0\b0 \cf0  checkerRow()\{\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0
\f1\b \cf5 while
\f0\b0 \cf0  (frontIsClear())\{\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0putBeeper();\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0move();\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0
\f1\b \cf5 if
\f0\b0 \cf0  (frontIsClear())\{\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0move();\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\}\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\}\
\'a0\'a0\'a0\'a0\}\
\'a0\'a0\'a0\'a0\'a0\
\pard\intbl\itap1\pardeftab720\sl260
\cf2 /* Checks whether there is a beeper on the first column of the lower row to \cf0 \
\'a0\cf2 * determine the checkering pattern for current row.\cf0 \
\'a0\cf2 * Precondition: Karel is on the first column facing east.\cf0 \
\'a0\cf2 * Postcondition: Karel will move forward one step if there is a beeper on the \cf0 \
\'a0\cf2 * lower row's first column before beginning to checker, or will begin to checker\cf0 \
\'a0\cf2 * in current position if there is not. \cf0 \
\'a0\cf2 */\cf0 \
\'a0\'a0\'a0\'a0
\f1\b \cf5 private
\f0\b0 \cf0  
\f1\b \cf5 void
\f0\b0 \cf0  checkForBeeperFirstColumn()\{\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0
\f1\b \cf5 if
\f0\b0 \cf0  (rightIsClear() && frontIsClear())\{\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0dropOneRow();\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0
\f1\b \cf5 if
\f0\b0 \cf0  (beepersPresent())\{\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0moveUpAndRight();\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\}\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0
\f1\b \cf5 else
\f0\b0 \cf0  \{\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0returnToStart();\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\}\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\}\
\'a0\
\'a0\'a0\'a0\'a0\}\
\'a0\
\cf2 /* Sends Karel to the first column of the above row.\cf0 \
\'a0\cf2 * Precondition: Karel is on the last column facing east.\cf0 \
\'a0\cf2 * Postcondition: Karel is on the first column of the above row \cf0 \
\'a0\cf2 * facing east. \cf0 \
\'a0\cf2 */\cf0 \
\'a0\'a0\'a0\'a0
\f1\b \cf5 private
\f0\b0 \cf0  
\f1\b \cf5 void
\f0\b0 \cf0  returnToFirstAvenue()\{\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0
\f1\b \cf5 if
\f0\b0 \cf0  (leftIsClear())\{\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0riseOneRow();\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0moveAcrossRow();\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\}\'a0\'a0 \
\'a0\'a0\'a0\'a0\}\
\'a0\'a0\'a0\'a0\'a0\
\cf2 /* Karel moves down one row\cf0 \
\'a0\cf2 * Precondition: There is a row underneath Karel's current \cf0 \
\'a0\cf2 * position\cf0 \
\'a0\cf2 * Postcondition: Karel is one row under in the same column\cf0 \
\'a0\cf2 * as it started and is facing Soitj\cf0 \
\'a0\cf2 */\cf0 \
\'a0\'a0\'a0\'a0
\f1\b \cf5 private
\f0\b0 \cf0  
\f1\b \cf5 void
\f0\b0 \cf0  dropOneRow()\{\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0turnRight();\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0move();\
\'a0\'a0\'a0\'a0\}\
\'a0\'a0\'a0\'a0\'a0\
\cf2 /* Karel moves up and right.\cf0 \
\'a0\cf2 * Precondition: Karel is one row and to the left of desired\cf0 \
\'a0\cf2 * destination\cf0 \
\'a0\cf2 * Postcondition: Karel is at the desired condition, up and left\cf0 \
\'a0\cf2 * of its start\'a0 \cf0 \
\'a0\cf2 */\cf0 \
\'a0\'a0\'a0\'a0
\f1\b \cf5 private
\f0\b0 \cf0  
\f1\b \cf5 void
\f0\b0 \cf0  moveUpAndRight()\{\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0turnAround();\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0move();\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0turnRight();\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0move();\
\'a0\'a0\'a0\'a0\}\
\'a0\'a0\'a0\'a0\'a0\
\cf2 /* Returns Karel to its original location\cf0 \
\'a0\cf2 * Precondition:\'a0 Karel is facing South.\'a0\'a0\'a0 \cf0 \
\'a0\cf2 * PostCondition: Karel returns to its original location facing \cf0 \
\'a0\cf2 * East. \cf0 \
\'a0\cf2 */\cf0 \
\'a0\'a0\'a0\'a0
\f1\b \cf5 private
\f0\b0 \cf0  
\f1\b \cf5 void
\f0\b0 \cf0  returnToStart()\{\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0turnAround();\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0move();\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0turnRight();\
\'a0\'a0\'a0\'a0\}\
\'a0\'a0\'a0\'a0\'a0\
\cf2 /* Karel moves away from its starting forward direction.\cf0 \
\'a0\cf2 * Precondition: Karel needs to move one row in reverse.\cf0 \
\'a0\cf2 * Postcondition: Karel is one row in reverse and is facing\cf0 \
\'a0\cf2 * in the opposite direction.\cf0 \
\'a0\cf2 */\cf0 \
\'a0\'a0\'a0\'a0
\f1\b \cf5 private
\f0\b0 \cf0  
\f1\b \cf5 void
\f0\b0 \cf0  moveBack()\{\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0turnAround();\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0
\f1\b \cf5 if
\f0\b0 \cf0  (frontIsClear())\{\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0move();\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\}\
\'a0\'a0\'a0\'a0\}\
\'a0\'a0\'a0\'a0\'a0\
\cf2 /* Karel rises one row.\cf0 \
\'a0\cf2 * Precondition: Karel is one row under desired location facing East.\cf0 \
\'a0\cf2 * Postcondition: Karel is one row above facing West.\'a0\'a0 \cf0 \
\'a0\cf2 */\cf0 \
\'a0\'a0\'a0\'a0
\f1\b \cf5 private
\f0\b0 \cf0  
\f1\b \cf5 void
\f0\b0 \cf0  riseOneRow()\{\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0turnLeft();\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0move();\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0turnLeft();\
\'a0\'a0\'a0\'a0\}\
\'a0\'a0\'a0\'a0\'a0\
\cf2 /* Karel moves across its current row.\cf0 \
\'a0\cf2 * Precondition: Karel is at either end of a row.\cf0 \
\'a0\cf2 * Postcondition: Karel is across the row, facing on the other \cf0 \
\'a0\cf2 * direction.\'a0\'a0 \cf0 \
\'a0\cf2 */\cf0 \
\'a0\'a0\'a0\'a0
\f1\b \cf5 private
\f0\b0 \cf0  
\f1\b \cf5 void
\f0\b0 \cf0  moveAcrossRow()\{\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0
\f1\b \cf5 while
\f0\b0 \cf0  (frontIsClear())\{\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0move();\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\}\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0turnAround();\
\'a0\'a0\'a0\'a0\}\
\'a0\'a0\'a0\'a0\'a0\
\cf2 /* Checks whether there should be a beeper in the final column\cf0 \
\'a0\cf2 * Precondition: Karel is on the last column facing east.\cf0 \
\'a0\cf2 * Postcondition: Karel returns to its initial position, and there is \cf0 \
\'a0\cf2 * a beeper on the last column depending on whether there \cf0 \
\'a0\cf2 * is a beeper on the prior column\'a0 \cf0 \
\'a0\cf2 */\cf0 \
\'a0\'a0\'a0\'a0
\f1\b \cf5 private
\f0\b0 \cf0  
\f1\b \cf5 void
\f0\b0 \cf0  checkForBeeperLastColumn()\{\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0moveBack();\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0
\f1\b \cf5 if
\f0\b0 \cf0  (beepersPresent())\{\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0moveBack();\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\}\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0
\f1\b \cf5 else
\f0\b0 \cf0 \{\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0moveBack();\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0putBeeper();\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\}\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\
\'a0\'a0\'a0\'a0\}\
\'a0\'a0\'a0\'a0\'a0\
\cf2 /* Creates a checkerboard pattern for a 1 column wide world.\cf0 \
\'a0\cf2 * Precondition: Karel is at the bottom of a 1 column-wide world.\cf0 \
\'a0\cf2 * Postcondition: Karel is at the top of the column, and the\cf0 \
\'a0\cf2 * column has been checkered.\cf0 \
\'a0\cf2 */\cf0 \
\'a0\'a0\'a0\'a0
\f1\b \cf5 private
\f0\b0 \cf0  
\f1\b \cf5 void
\f0\b0 \cf0  checkerColumn()\{\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0turnLeft();\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0checkerRow();\
\'a0\'a0\'a0\'a0\}\
\}\'a0\'a0\cell \lastrow\row
}